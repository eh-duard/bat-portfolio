---
interface Props {
  ambientVolume?: number;
  effectVolume?: number;
  titleText?: string;
  enableText?: string;
  skipText?: string;
}

const { 
  ambientVolume = 0.3,
  effectVolume = 0.5,
  titleText = 'Esperienza audio immersiva',
  enableText = 'Attiva Audio',
  skipText = 'Continua senza'
} = Astro.props;

const baseUrl = import.meta.env.BASE_URL.endsWith('/') 
  ? import.meta.env.BASE_URL 
  : import.meta.env.BASE_URL + '/';
---

<!-- Audio Gate - shown at start -->
<div id="audio-gate" class="audio-gate">
  <div class="gate-content">
    <div class="gate-icon">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
        <path d="M11 5L6 9H2v6h4l5 4V5z"/>
        <path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"/>
      </svg>
    </div>
    <p class="gate-text" data-i18n="audio.title">{titleText}</p>
    <div class="gate-buttons">
      <button id="audio-enable" class="gate-btn gate-btn-primary" data-i18n="audio.enable">
        {enableText}
      </button>
      <button id="audio-skip" class="gate-btn gate-btn-secondary" data-i18n="audio.skip">
        {skipText}
      </button>
    </div>
  </div>
</div>

<!-- Audio Toggle Button (bottom right) -->
<div id="audio-controller" class="audio-controller hidden">
  <button 
    id="audio-toggle" 
    class="audio-toggle muted" 
    aria-label="Toggle audio"
    title="Toggle audio"
  >
    <svg class="icon-sound-on" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path d="M11 5L6 9H2v6h4l5 4V5z"/>
      <path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"/>
    </svg>
    <svg class="icon-sound-off" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path d="M11 5L6 9H2v6h4l5 4V5z"/>
      <line x1="23" y1="9" x2="17" y2="15"/>
      <line x1="17" y1="9" x2="23" y2="15"/>
    </svg>
  </button>
</div>

<audio id="ambient-audio" loop preload="auto">
  <source src={`${baseUrl}sounds/ambient.mp3`} type="audio/mpeg" />
</audio>

<audio id="ambient-audio-2" loop preload="auto">
  <source src={`${baseUrl}sounds/ambient.mp3`} type="audio/mpeg" />
</audio>

<audio id="found-audio" preload="auto">
  <source src={`${baseUrl}sounds/found.mp3`} type="audio/mpeg" />
</audio>

<style>
  @import url('https://fonts.googleapis.com/css2?family=Staatliches&display=swap');

  /* Audio Gate Overlay */
  .audio-gate {
    position: fixed;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    background: #05050a;
    z-index: calc(var(--z-audio) + 100);
    transition: opacity 0.5s ease, visibility 0.5s ease;
    overflow: hidden;
    touch-action: none;
  }

  .audio-gate::before {
    content: '';
    position: absolute;
    inset: 0;
    background: radial-gradient(ellipse at 50% 35%, rgba(255, 215, 0, 0.06) 0%, rgba(7, 7, 14, 0.92) 45%, #05050a 100%);
    pointer-events: none;
  }

  .audio-gate.hidden {
    opacity: 0;
    visibility: hidden;
    pointer-events: none;
  }

  .gate-content {
    text-align: center;
    padding: var(--space-xl);
    background: rgba(10, 10, 20, 0.7);
    border: 1px solid rgba(255, 215, 0, 0.35);
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6), inset 0 0 30px rgba(255, 215, 0, 0.08);
    border-radius: 16px;
    backdrop-filter: blur(6px);
  }

  .gate-icon {
    width: 84px;
    height: 84px;
    margin: 0 auto var(--space-lg);
    color: #ffd700;
    animation: pulse-glow 2s ease-in-out infinite;
    filter: drop-shadow(0 0 12px rgba(255, 215, 0, 0.35));
  }

  .gate-icon svg {
    width: 100%;
    height: 100%;
  }

  @keyframes pulse-glow {
    0%, 100% { 
      opacity: 0.6;
      filter: drop-shadow(0 0 10px rgba(255, 215, 0, 0.3));
    }
    50% { 
      opacity: 1;
      filter: drop-shadow(0 0 20px #ffd700);
    }
  }

  .gate-text {
    font-family: 'Staatliches', 'Cardo', 'Garamond', 'Georgia', serif;
    font-size: clamp(1.1rem, 3.5vw, 1.6rem);
    color: #f5f6fb;
    margin-bottom: var(--space-lg);
    letter-spacing: 0.14em;
    text-transform: uppercase;
    text-shadow: 0 0 18px rgba(255, 215, 0, 0.35), 0 0 4px rgba(0, 0, 0, 0.8);
  }

  .gate-buttons {
    display: flex;
    flex-direction: column;
    gap: var(--space-sm);
    max-width: 260px;
    margin: 0 auto;
  }

  .gate-btn {
    padding: var(--space-md) var(--space-lg);
    font-family: 'Staatliches', 'Cardo', 'Garamond', 'Georgia', serif;
    font-size: 1rem;
    letter-spacing: 0.12em;
    border-radius: 999px;
    cursor: pointer;
    transition: all var(--transition-fast);
    -webkit-tap-highlight-color: transparent;
    touch-action: manipulation;
    user-select: none;
    text-transform: uppercase;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.45);
  }

  .gate-btn-primary {
    background: linear-gradient(135deg, #ffd700, #ffbf00);
    color: #0a0a0a;
    border: 2px solid #ffd700;
  }

  .gate-btn-primary:hover,
  .gate-btn-primary:active {
    background: linear-gradient(135deg, #ffed4a, #ffd000);
    border-color: #ffed4a;
    transform: translateY(-1px) scale(1.02);
  }

  .gate-btn-secondary {
    background: rgba(255, 215, 0, 0.05);
    color: #d1d5db;
    border: 1px solid rgba(255, 215, 0, 0.35);
  }

  .gate-btn-secondary:hover,
  .gate-btn-secondary:active {
    color: #ffd700;
    border-color: #ffd700;
    background: rgba(255, 215, 0, 0.12);
    transform: translateY(-1px) scale(1.02);
  }

  /* Audio Controller */
  .audio-controller {
    position: fixed;
    bottom: var(--space-md);
    right: var(--space-md);
    z-index: var(--z-audio);
    transition: opacity 0.3s ease, visibility 0.3s ease;
  }

  .audio-controller.hidden {
    opacity: 0;
    visibility: hidden;
  }

  .audio-toggle {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 48px;
    height: 48px;
    padding: 0;
    background: var(--color-bg-secondary);
    border: 1px solid var(--color-accent-dim);
    border-radius: 50%;
    color: var(--color-accent);
    cursor: pointer;
    transition: all var(--transition-fast);
  }

  .audio-toggle:hover {
    background: var(--color-bg-tertiary);
    border-color: var(--color-accent);
    transform: scale(1.05);
  }

  .audio-toggle svg {
    width: 24px;
    height: 24px;
  }

  .audio-toggle .icon-sound-off {
    display: none;
  }

  .audio-toggle.muted .icon-sound-on {
    display: none;
  }

  .audio-toggle.muted .icon-sound-off {
    display: block;
  }
</style>

<script define:vars={{ ambientVolume, effectVolume }}>
  class AudioController {
    constructor() {
      this.gate = document.getElementById('audio-gate');
      this.enableBtn = document.getElementById('audio-enable');
      this.skipBtn = document.getElementById('audio-skip');
      this.controller = document.getElementById('audio-controller');
      this.toggleBtn = document.getElementById('audio-toggle');
      this.ambientAudio = document.getElementById('ambient-audio');
      this.ambientAudio2 = document.getElementById('ambient-audio-2');
      this.foundAudio = document.getElementById('found-audio');
      
      this.isMuted = true;
      this.isReady = false; // Prevent found sound before user interaction
      this.isUnlocking = false; // Track if we're in the middle of unlocking audio
      this.hasFoundLogo = false; // Prevent multiple found sounds
      this.crossfadeInterval = null;
      
      this.ambientAudio.volume = ambientVolume;
      this.ambientAudio2.volume = 0;
      this.foundAudio.volume = effectVolume;
      
      this.init();
    }

    init() {
      this.bindEvents();
      this.setupCrossfade();
    }

    setupCrossfade() {
      // When first audio is about to end, start crossfade to second
      this.ambientAudio.addEventListener('timeupdate', () => {
        const timeLeft = this.ambientAudio.duration - this.ambientAudio.currentTime;
        if (timeLeft <= 1 && timeLeft > 0 && !this.isMuted && this.ambientAudio2.paused) {
          this.startCrossfade(this.ambientAudio, this.ambientAudio2);
        }
      });
      
      this.ambientAudio2.addEventListener('timeupdate', () => {
        const timeLeft = this.ambientAudio2.duration - this.ambientAudio2.currentTime;
        if (timeLeft <= 1 && timeLeft > 0 && !this.isMuted && this.ambientAudio.paused) {
          this.startCrossfade(this.ambientAudio2, this.ambientAudio);
        }
      });
    }

    startCrossfade(fromAudio, toAudio) {
      toAudio.currentTime = 0;
      toAudio.volume = 0;
      toAudio.play().catch(() => {});
      
      const fadeStep = 0.05;
      const fadeInterval = 50; // 50ms steps = 1 sec total fade
      
      const fade = setInterval(() => {
        if (fromAudio.volume > fadeStep) {
          fromAudio.volume -= fadeStep;
        } else {
          fromAudio.volume = 0;
          fromAudio.pause();
        }
        
        if (toAudio.volume < ambientVolume - fadeStep) {
          toAudio.volume += fadeStep;
        } else {
          toAudio.volume = ambientVolume;
          clearInterval(fade);
        }
      }, fadeInterval);
    }

    bindEvents() {
      this.enableBtn.addEventListener('click', () => this.startWithAudio());
      this.skipBtn.addEventListener('click', () => this.startWithoutAudio());
      this.toggleBtn.addEventListener('click', () => this.toggle());
      
      document.addEventListener('logo-found', () => this.playFoundSound());
    }

    startWithAudio() {
      this.isMuted = false;
      this.isUnlocking = true; // Mark that we're unlocking
      this.hideGate();
      
      // Unlock ALL audio elements on user interaction (required for iOS/mobile)
      // Set volume to 0 during unlock to prevent hearing it
      const originalFoundVolume = effectVolume;
      
      this.foundAudio.volume = 0;
      this.ambientAudio2.volume = 0;
      
      let unlockCount = 0;
      const checkUnlockComplete = () => {
        unlockCount++;
        if (unlockCount >= 2) {
          // Both audio elements unlocked, now safe to play found sound
          this.isUnlocking = false;
          this.isReady = true;
        }
      };
      
      this.foundAudio.play().then(() => {
        this.foundAudio.pause();
        this.foundAudio.currentTime = 0;
        this.foundAudio.volume = originalFoundVolume;
        checkUnlockComplete();
      }).catch(() => {
        this.foundAudio.volume = originalFoundVolume;
        checkUnlockComplete();
      });
      
      this.ambientAudio2.play().then(() => {
        this.ambientAudio2.pause();
        this.ambientAudio2.currentTime = 0;
        checkUnlockComplete();
      }).catch(() => {
        checkUnlockComplete();
      });
      
      this.playAmbient();
      this.updateUI();
    }

    startWithoutAudio() {
      this.isMuted = true;
      this.isReady = true;
      this.hideGate();
      this.updateUI();
    }

    hideGate() {
      this.gate.classList.add('hidden');
      this.controller.classList.remove('hidden');
    }

    toggle() {
      this.isMuted = !this.isMuted;
      this.updateUI();
      
      if (this.isMuted) {
        this.ambientAudio.pause();
        this.ambientAudio2.pause();
      } else {
        this.playAmbient();
      }
    }

    updateUI() {
      this.toggleBtn.classList.toggle('muted', this.isMuted);
    }

    playAmbient() {
      this.ambientAudio.volume = ambientVolume;
      this.ambientAudio.play().catch(() => {});
    }

    playFoundSound() {
      // Only play if: not muted, ready (unlock complete), not unlocking, and not already played
      if (this.isMuted || !this.isReady || this.isUnlocking || this.hasFoundLogo) return;
      
      this.hasFoundLogo = true; // Prevent playing again
      
      // Stop ambient immediately
      this.ambientAudio.pause();
      this.ambientAudio.currentTime = 0;
      this.ambientAudio.volume = ambientVolume;
      this.ambientAudio2.pause();
      this.ambientAudio2.currentTime = 0;
      this.ambientAudio2.volume = 0;
      
      // Play found effect
      this.foundAudio.currentTime = 0;
      this.foundAudio.play().catch(() => {});
    }
  }

  document.addEventListener('DOMContentLoaded', () => {
    new AudioController();
  });
</script>
